* В чем важность объектов в C++?
** *Объекты и классы - строительные блоки программы на С++. Объединяя данные и алгоритмы (код) в единое целое, программа на С++ представляет компоненты моделируемой системы, а также их взаимодействия.*
Объектно-ориентированное программирование – это способ структурировать программу, объединив алгоритм и данные, которыми он оперирует, в единую сущность, именуемую *объектом*.
*Класс* – это определение объекта, он описывает алгоритм и данные, формат объекта и связи с другими классами.
*Объект* – это конкретный экземпляр класса, т. е. переменная. У объекта есть адрес, по которому он расположен в памяти.
Алгоритмы реализованы в виде функций – *методов класса*.
Идея *инкапсуляции* является центральной для классов в C++ – язык позволяет управлять тем, какие данные-члены и методы открыты (~public~), т. е. видимы извне класса, а какие закрыты (~private~), т. е. являются внутренними для класса. В хорошо спроектированном классе большая часть данных-членов, или даже все они, закрыты, а для выражения открытого интерфейса класса, т. е. того, что он делает, нужны только открытые методы.
Концепция *наследования* является центральной для использования классов и объектов в C++. Наследование позволяет определять новые классы как расширения существующих. Производный класс, наследующий базовому, содержит в той или иной форме все данные и алгоритмы, присутствующие в базовом классе, и добавляет свои собственные. В C++ важно различать два основных типа наследования: *открытое* и *закрыто
* Какое отношение выражает открытое наследование?
** *Открытое наследование представляет отношение является между объектами - объект производного класса можно использовать так, как будто он является объектом базового класса. Из этого отношения вытекает, что интерфейс базового класса со всеми его инвариантами и ограничениями также является интерфейсом производного класса.*
В случае открытого наследования наследуется интерфейс класса. Наследуется и его реализация – данные-члены базового класса являются также членами производного. Но именно наследование интерфейса – отличительная черта открытого наследования; это означает, что частью открытого интерфейса производного класса являются все открытые функции-члены базового.
Oткрытый интерфейс подобен контракту – мы обещаем клиентам класса, что он будет поддерживать определенные операции, сохранять некоторые инварианты и подчиняться специфицированным ограничениям. Открыто наследуя базовому классу, мы связываем производный класс тем же контрактом (и, возможно, расширяем его, если решим определить дополнительные открытые интерфейсы).
Принцип *является* – экземпляр производного класса является также экземпляром базового класса.
* Какое отношение выражает закрытое наследование?
** *В отличие от открытого наследования, закрытое наследование ничего не говорит об интерфейсах. Оно выражает отношение /содержит или реализован в терминах/. Производный класс повторно использует реализацию, предоставленную базовым классом. Обычно того же результата можно достичь с помодщью композиции. Если возможно, следует остановиться на композиции, однако оптимизация пустого базового класса и (реже) переопределение виртуальных методов - веские основания для использования закрытого наследования.*
В случае закрытого наследования производный класс не расширяет открытый интерфейс базового – все методы базового класса становятся закрытыми в производном.  Открытый интерфейс должен быть определен производным классом с чистого листа. Не предполагается, что объект производного класса можно использовать вместо объекта базового. Единственное, что производный класс получает от базового, – детали реализации, т. е. может использовать его методы и данные-члены для реализации собственных алгоритмов. Поэтому говорят, что закрытое наследование реализует отношение *содержит* – внутри производного объекта находится экземпляр базового класса.
* Что такое полиморфный объект?
** *Полиморфным объектом в С++ называется объект, поведение которого зависит от его типа, а тип неизвестен на этапе компиляции (по крайней мере, в точке, где опрашивается интересующее поведение). Объект, к которому общаются как к объекту базового класса, может демонстрировать поведение производного класса, если таков истинный тип. В С++ полиморфное поведение реализуется с помощью виртуальных функций.*
Техника программирования, при которой некий код работает с произвольным числом базовых объектов и вызывает одни и те же методы, но результат зависит от фактических типов этих объектов, называется *полиморфизмом времени выполнения*, а объекты, поддерживающие эту технику, – *полиморфными*. В C++ *полиморфный объект* должен иметь хотя бы одну виртуальную функцию, и только те части его интерфейса, в которых используются виртуальные функции, являются *полиморфными*.
* В чем разница между *типом* и *шаблоном*?
** *Шаблон не является типом, это /фабрика/ по изготовлению различных типов с похожей структурой. Шаблон пишется в терминах обобщенных типов; подстановка конкретных типов вместо обобщенных дает порождаемый по шаблону тип.*
В обобщенном программировании алгоритмы и структуры данных записываются в терминах обобщенных типов, которые могут быть заданы позднее. Шаблоны - это средство С++, позволяющее определить классы и функции для обобщенных типов.
* Какие виды *шаблонов* имеются в С++?
** *Существуют шаблоны классов, функций и переменных. Каждый вид шаблона генерирует соотвествующие сущности - функции по шаблону функции. классы (типы) по шаблону класса, переменные по шаблону переменной.*
** Шаблоны функций
Обобщенные функции, для которых не объявлены типы переменных. Шаблонами могут быть как свободные функции, так и функции-члены класса, но не виртуальные функции. Обобщенные типы можно использовать как для объявления параметров, так и любых переменных в теле функции.
** Шаблоны классов
Это классы, в которых используются обобщенные типы, как в объявлениях данных-членов, так и в объявлении методов и их локальных переменных.
** Шаблоны переменных
Переменных обобщенного типа.
* Какие виды параметров могут быть у *шаблонов* С++?
** *У шаблонов могут быть параметры-типы и параметры-нетипы. Параметрами-нетипами могут быть целые числа или перечислимые значения, а также шаблоны (в случае шаблонов с переменным числом аргументов подстановочные маркеры также являются параметрами-нетипами).*
** Типы
** Значения - константы, известные во время компиляции, числа или constexpr-функции
** Шаблоны
* В чем разница между *конкретизацией* и *специализацией* шаблонов?
** *Конкретизация шаблона - это код, сгенерированный по шаблону. Обычно конкретизация производится неявно, в точке использования шаблона. Возможна также явная конкретизация, без использования; при этом генерируется тип или функция для последующего использования. В случае явной специализации шаблона задаются все обобщенные типы; это не конкретизация, и никакой код не генерируется, пока шаблон не будет использован. Это лишь альтернативный рецепт генерации кода для этих и только этих типов.*
** Конкретизация шаблонов функций - указание типов, подставляемых вместо всех параметров-типов шаблона
** Конкретизация шаблонов класса - задание типов параметров шаблона
** Специализация шаблона - для генерации различных кодов для некоторых типов
*** Явная или полная специализация
Определяется специальная версия шаблона для определенного набора типов. Все обобщенные типы заменяются на конкретные. Явная специализация не требует дальнейшей конкретизации.
*** Частичная специализация
Частично специализированный шаблон класса остается обобщенным кодом, но в меньшей степени, чем исходный, когда только некоторые обобщенные типы заменяются конкретными.
* Как осуществляется доступ к пакету параметров *шаблона* с переменным числом аргументов?
** *Обычно пакет параметров обходится с помощью рекурсии. Как правило, компилятор встраивает код, сгенерированный в процессе рекурсии, поэтому рекурсия существует только во время компиляции. В С++17 (и редко в С++14) можно оперировать всем пакетом без рекурсии.*
С помощью рекурсии
* Для чего применяются лямбда-выражения?
** *Лямбда-выражения - это по существу компактный способ объявления локальных классов, которые можно вызывать, как функции. Они используются, чтобы сохранить фрагмент кода в переменной (а точнее, ассоциировать код с переменно), так чтобы этот код можно было вызывать впоследствии.*
Для объявления функций внутри функций.
* Почему так важно четко выражать, кто владеет памятью в программе?
** *Ясное выражение того, кто владеет памятью и вообще любым ресурсом, - один из ключевых признаков хорошего проекта. Если владелец четко определен, то гарантируется, что ресурс создан и доступен к моменту, когда в нем возникает необходимость, существует на протяжении всего времени использования и освобожден или очищен, когда необходимость в нем отпадает.*
В С++ *владение памятью* относится к сущности, которая отвечает за обеспечение времени жизни определенной области выделенной памяти. На практике управлению подвергается владение и время жизни объектов, расположенных в области памяти, а под владением памятью понимается /владение объектом/. В С++ управление ресурсами (и памятью в том числе) перепоручается объектам, владеющими ими. Задача управления ресурсами суть задача управление объектами-владельцами. Неправильное управление владением может приводить к утечкам, ошибкам при подсчете или потере ресурсов, управляемых программой: памяти, мьютексов, файлов, описателей баз данных и т.д.
Правильное спроектированное владение памятью:
 - в каждой точке программы понятно, кто какими объектами владеет. (чересчур ограничительно)
 - в каждой точке программы понятно, кто владеет данным объектом или что владение не изменяется. (менее ограничительно)
 -
   1. если некоторая функция или класс никак не изменяют владение памятью, то это должно быть понятно каждому клиенту, а также автору функции или класса
   2. если некоторая функция или класс принимают монопольное владение некоторыми переданными объектами, то это должно быть понять клиенту
   3. если некоторая функция или класс разделяет владение переданным объектом, то это должно быть понятно клиенту
   4. для любого созданного объекта в любой точке, где он используется, понятно, должен код удалить объект или нет
* Каковы типичные проблемы из-за нечеткого указания владельца памяти?
** *Наиболее типичные проблемы - утечка ресурсов, в т.ч. утечка памяти; висячие описатели (например, указатели, ссылки или итераторы, указывающие на ресурсы, которые уже не существуют); многократные попытки освободить один и тот же ресурс.*
Знание о владение кодом ресурса требует дополнительной информации, невыводимой из контекста, например, ожидается ли, что клиент удалит объект, если в нем отпадет необходимость, владеет ли данная функция созданными ею объектами, будут ли объекты удалены вместе с удалением порождающего их объекта, и т.д. - утечка памяти, обращение к удаленным объектам, и тд
* Какие виды владения памятью можно выразить в С++?
** *Невладение, монопольное владение, совместное владение, а также преобразование между различными типами владения и передачу владений.*
** доступ без передачи владения
** монопольное владение
** coвместное владение
Оправдано на низком уровне, внутри таких структур данных, как списки, деревья и т.д. Элементом данных могут владеть другие узлы той структуры, на него может указывать несколько итераторов и какие временные переменные внутри функций-членов структуры, которые работают со всей структурой или ее частью (перебалансировка деревьев). Владение отдельными узлами или элементами данных может быть по-настоящему совместным в том смысле, что все владельцы равны, нет ни привилегированных владельцев, ни главного.
* Как писать функции и классы, не владеющие памятью?
** *Безразличные к владению функции и классы должны обращаться к объектам по простым указателям и ссылкам*
Доступ к объекту без передачи владения следует предоставлять с помощью простых указателей и ссылок. Ссылка - по существу указатель, который не может принимать значение NULL и не может быть неинициализированным. Любой указатель, передаваемый функции, может быть равен NULL и должен проверяться.
* Почему монопольное владение памятью предпочтительнее совместного?
** *Монопольное владение памятью проще понять и проследить по потоку управления в программе. Оно также более эффективно.*
* Как выразить монопольное владение памятью в С++?
** *Предпочтительно путем создания объекта в стеке или как члена данных владеющего класса (в т.ч. и контейнерного). Если необходима семантика ссылки или перемещения, то следует использовать уникальный указатель.*
код создает объект и затем удаляет его. Задача удаления никому не делегируется, поскольку расширение времени жизни объекта не допускается. Все локальные (стековые) переменные выражают монопольное владение памятью. Модификация объекта допускается. Для объектов в куче, когда размер или тип объекта неизвестен на этапе компиляции (полиморфный объект) - создается производный объект, но используется указатель на базовый класс. С помощью std::unique_ptr
Передача другому владельцу
#+BEGIN_SRC c++
  std:: unique_ptr<Widget> WidgetFactory() {
    Widget* new_w = new Widget ;
    return std::unique_ptr<Widget>(new_w);
  }
  std::unique_ptr<Widget> w(WidgetFactory());
#+END_SRC
При перемещении содержимого уникального указателя в другой уникальный указатель передается владение объектом; исходный указатель остается в состоянии «Перемещен из» (его уничтожение не приводит к удалению каких-либо объектов).
#+BEGIN_SRC c++
void Consume( Widget&& w) { auto my_w = std::move(w) ; . . . }
Widget w, wl;
Consume(std::move(w)); // нет больwе w - он теперь в состоянии "nеремещен из"
Consume(wl); // не компилируется, нужно согласие на nеремещение
#+END_SRC
* Как выразить совместное владение памятью в С++?
** *Для выражения совместного владения следует использовать разделяемый указатель, например ~std::shared_ptr~*
~std::shared_ptr<T>~
#+BEGIN_SRC c++
  struct ListNode {
    T data;
    std::shared_ptr<ListNode> next, prev;
  };
  class ListIterator {
    std::shared_ptr<ListNode> node_p;
  };
#+END_SRC
* Каковы потенциальные недостатки совместного владения памятью?
** *В большой системе совместным владением трудно управлять, из-за него ресурсы могут освобождаться с задержкой без всякой на то необходимости. Кроме того, по сравнению с монопольным владением, у совместного владения нетривиальные накладные расходы. Для потокобезопасного управления совместным владением в конкуретной программе реализация должна быть написана очень аккуратно.*
 "Проклятие разделяемых указателей" - циклическая зависимость, когда два указателя указывают друг на друга, тогда вся пара остается /активной/ неопределенно долго. В таком случае нужно применять ~std::weak_ptr~ - указатель на объект, который возможно уже удален. Производительность разделяемого указателя нииже, чем простого, а уникальный указатель может работать так же эффективно, как простой. При первом создании разделяемого указателя выделяется дополнительная память для счетчика ссылок. Копирование или удаление разделяемого указателя должно сопровождаться модификацией счетчика. Трудно спроектировать потокобезопасный во всех контекстах разделяемый указатель, что влечет за собой дополнительные накладные расходы.
* идиома pimpl (p_impl pointer to implementation - указатель на реализацию) - описатель-тело
Основное применение - минимизировать количество зависимостей на этапе компиляции и избежать раскрытия реализации класса в заголовочном файле. Смысл идиомы - всё объявления класса в заголовочном файле состоит из необходимых открытх функций-членов плюс единственный указатель на настоящую реализацию. Реализация и тела функций-членов находятся в С-файле.
#+BEGIN_SRC c++
  // in C.h
  class C_impl; // опережающее объявление
  class C {
   public:
    void swap(C& rhs) noexcept {
      swap(pimpl_, rhs.pimpl_);
    }
    void f();
   private:
    C_impl* pimpl_;
  };
  // in C-file
  class C_impl {
    // true implementation
  };
  void C::f() {
    pimpl_->f(); // true implementation of C::f()
  }
#+END_SRC
* Поиск, зависящий от аргументов (Argument-Dependent Lookup - ADL) поиск Кёнинга
Механизм ADL добавляет во множество разрешения перегрузки все функции, объявленные в тех областях видимости, где объявлены аргументы функции.
* Что делает операция обмена?
** *Обменивает состояния двух объектов. После нее объекты должны остаться неизменными, за исключением имен, по которым к ним обращаются.*
Перестановка содержимых двух объектов.
* Как обмен используется в программах, безопасных относительно исключений?
** *Обмен обычно используется в программах, предоставляющих семантику фиксации или отката; сначала создается временная копия результата, а затем, если не было ошибок, она обменивается с окончательным результатом.*
В виде идиом "копирование и обмен", сброс значения объекта в состояние после конструирование по умолчанию, преобразование к исходному объекту, не изменяя его имени, или с новыми данными.
* Почему функция swap не должна возбуждать исключений?
** *Использование обмена для предоставления семантики фиксации или отката подразумевает, что сама операция обмена не может возбуждать исключений или как-то иначе завершаться аномально, оставив обмениваемые объекты в неопредленном состоянии.*
Для использования в идиомах, которые не должны возбуждать исключений
* Какую реализацию swap следует предпочесть: в виде функции-члена или свободной функции?
** *Свободную функцию* ~swap~ *следует предоставлять всегда и гарантироват, что обращения к ней выполняются корректно. Функцию-член также можно предоставить по двум причинам: во-первых, это единственный способ обменять объект с временным объектом, а во-вторых, для реализации обмена обычно нужен доступ к закрытым данным-членам класса. Если предоставлено то и другое, то свободная функция должна вызывать функцию-член от имени одного из двух своих параметров.*
#+BEGIN_SRC c++
  class C {
   public:
    void swap(C& rhs) noexcept;
  };
#+END_SRC
Для многих классов можно просто обменивать данные-члены один за другим. Это делегирует задачу обмена объектов их типам, и если все типы следуют этому образцу, то в конечном итоге все сведется к обмену встроенных типов, из которых все и состоит. Если наперед известно, что в классе члена данных имеется функция swap, то можно вызвать ее. В противном случае придется вызывать свободную функцию обмена.
#+BEGIN_SRC c++
void C::swap(C& lhs, С& rhs) noexcept { lhs.swap(rhs ); }
#+END_SRC
* Как обмен реализован в классах из стандартной библиотеки?
** *Все контейнеры STL и некоторые другие классы из стандартной библиотеки представляют функцию-член* ~swap()~ *Кроме того, свободная шаблонная функция* ~std::swap()~ *имеет перегруженные варианты для всех типов из STL.*
В виде функции-члена для доступа к закрытым данным класса.
** классы, поддерживающие обмен, должны реализовать функцию член swap(), так чтобы она выполняала операцию за постоянное время
** для всех типов, допускающих обмен, должна быть предоставлена также свободная функция swap()
** обмен двух объектов не должен возбуждать исключений или еще каким-то образом отказывать.
Если в классе имеются операции перемещения не возбуждающие исключений, то возможна не возбуждающая исключений реализация обмена.
* Почему свободную функцию следует вызывать без квалификатора std::?
** *Квалификатор* ~std::~ *отключает механизм поиска, зависящего от аргументов, и заставляет компилятор вызвать конкретизацию шаблона* ~std::swap~ *по умолчанию, даже если в классе реализована собственная функция* ~swap~. *Чтобы избежать этой проблемы, рекомендуется также предоставлять явную специализацию шаблона* ~std::swap~.
Учитывая, что std::swap всегда доступна и может вызываться от имени любых объектов, допускающих копирование и перемещение, программист должен позаботиться о реализаци свободной функции swap, если для данного типа существует лучший способ обмена (в частности, любой тип с функцией-членом swap должен предоставлять также перегрузку свободной функции, которая будет вызывать функцию-член).
Если не соблюдается правило вызывать свободную функцию swap без префикса std::, нужно обеспечить явную специализацию шаблона std::swap.
#+BEGIN_SRC c++
  class C;
  C c1, c2;
  using std::swap;     // std::swap is accessible
  std::swap(c1, c2);   // calls the overloaded of std::swap, not std::swap
  swap(c1, c2);        // calls std::swap() by default
#+END_SRC

* Что понимается под /ресурсами/, которыми может управлять программа?
** *Память - наиболее распространенный ресурс, но вообще ресурсом может быть любой объект. Любая виртуальная или физическая сущность, которой оперирует программа, является ресурсом.*
* Каковы основные проблемы управления ресурсами в программе С++?
** *Ресурсы не должны теряться (утекать). Если для доступа к ресурсу используется описатель, например, указатель или идентификатор, то описатель не должен оставяться висячим (ссылаться на уже не существующий ресурс). Ресурсы следует освобождать, когда в них отпадает необходимость, причем способом, соответствующим их захвату.*
* Что такое RAII?
** *Идиома "захват ресурса есть инициализация" (RAII) - основной подход к управлению ресурсами в С++. Она означает, что ресурсом владеет некоторый объект, причем захват ресурса производится в конструкторе, а освобождение - в деструкторе этого объекта.*
* Как RAII решает проблему утечки ресурсов?
** *RAII-объект всегда должен создаватьс в стеке или как член данных другого объекта. Когда программа покидает область видимости, охватывающую RAII-объект или содержащий его объект, вызывается деструктор RAII-объекта. Это происходит вне зависимости от того, как именно программа покидает область видимости.*
* Как RAII решает проблему висячих описателей ресурсов?
** *Если каждым ресурсом владеет RAII-объект и RAII-объект не раскрывает простые описатели (или пользователь ведет себя осторожно и не клонирует простые описатели), то описатель можно получить только от RAII-объекта, и ресурс не освобождается, пока этот объект существует.*
* Какие RAII-объекты предоставляет стандартная библиотека C++?
** *Чаще всего используется* ~std::unique_ptr~ *для управления памятью; объект* ~std::lock_guard~ *предназначен для управления мьютексами.*
* О каких предосторожностях следует помнить при написании RAII-объектов?
** *Как правило, RAII-объекты не должны допускать копирование. Перемещение RAII-объекта передает владение ресурсом; классический паттерн RAII этого не поддерживает, поэтому обычно RAII-объекты следует делать неперемещаемыми (различайте* std::unique_ptr *и* ~const std::unique_ptr~ *)*
* Что происходит, когда освобождение ресурса завершается неудачно?
** *RAII испытывает трудности с обработкой ошибок освобождения, потому что исключения не могут распространяться наружу из деструкторов, а значит, нет хорошего способа сообщить об ошибке вызывающей стороне. Поэтому неудачное освобождение ресурса часто приводит к неопределенному поведению (иногда так поступает и стандарт С++)*
* Что собой представляет стирание типа?
** *Стирание типа - это техника программированя, при которой программа не показывает явной зависимости от некоторых используемых в ней типов.*
* Как стирание типа реализуется в C++?
** *Реализация всегда подразумевает наличие полиморфного объекта и вызов виртуальной функции или динамического приведения. Обычно это сочетается с обобщенным программированием для конструирования таких полиморфных объектов.*
* В чем разница между сокрытием типа за ключевым словом ~auto~ и его стиранием?
** 
* Как материализуется конкретный тип, когда у программы возникает в нем необходимость?
* Каковы издержки стирания типа?

* Что такое множество перегруженных вариантов?
* Что такое разрешение перегрузки?
* Что такое выведение типов и подстановки типов?
* Что такое SFINAE?
* В каких контекстах потенциально недопустимый код не приводит к ошибке компиляции, если только он не понадобится в действительности?
* Как можно определить, какой перегруженный вариант был выбран, не вызывая его?
* Как SFINAE применяется для управления условной компиляцией?

* Насколько дорого обходится вызов виртуальной функции и почему?
* Почему у вызова аналогичной функции, разрешаемого во время компиляции, нет никаких накладных расходов?
* Как реализовать вызовыв полиморфных функций на этапе компиляции?
* Как использовать CRTP для расширения интерфейса базового класса?

* ПОчему наличие функций с большим количеством аргументов одного или родственных типов приводит к хрупкости кода?
* Как агрегатные объекты в качестве аргументов повышают удобство сопровождения и надежность кода?
* Что такое идиома именованных аргументов и чем она отличается от агрегатного объекта-аргумента?
* В чем разница между сцеплением и каскадированием методов?

* Как измерить производительность небольшого фрагмента кода?
* Почему частое выделение небольших блоков памяти особенно вредит производительности?
* Что такое оптимизация локального буфера и как она работает?
* Почему выделение памяти для дополнительного буфера внутри объекта обходится по существу /бесплатно/?
* Что такое оптимизация короткой строки?
* Что такое оптимизация короткого вектора?
* Почему оптимизация локального буфера особенно эффективна для вызываемых объектов?
* Какие компромиссы необходимо рассмотреть при использовании оптимизации локального буфера?
* Когда объект не следует помещать в локальный буфер?

* Что такое программа, безопасная относительно ошибок или исключений?
* Как можно сделать безопасной относительно ошибок процедуру, выполняющую несколько взаимосвязанных действий?
* Как идиома RAII помогает писать программы, безопасные относительно ошибок?
* Как паттерн ScopeGuard обобщает идиому RAII?
* Как программа может автоматически определить, когда функция завершилась успешно, а когда - неудачно?
* Каковы достоинства и недостатки паттерна ScopeGuard со стертым типом?

* Каков эффект объявления функции /другом/?
* В чем разница между предоставлением дружественного доступа функции и шаблону функции?
* Почему бинарные операторы обычно реализуются как свободные функции?
* Почему оператор вывода в поток всегда реализуется в виде свободной функции?
* В чем основная разница между преобразованиями аргументов шаблонных и нешаблонных функций?
* Как сделать так, чтобы при конкретизации шаблона всегда генерировалась также уникальная нешаблонная свободная функция?

* Почему в  С++ не разрешены виртуальные конструкторы?
* Что такое паттерн Фабрика?
* Как паттерн Фабрика используется для создания эффекта виртуального конструктора?
* Как добиться эффекта виртального копирующего конструктора?
* Как паттерны Шаблонный метод и Фабрика используются совместно?

* Что такое поведенческий паттерн проектирования?
* Что такое паттерн Шаблонный метод?
* Почему Шаблонный метод считается поведенческим паттерном?
* Что такое инверсия управления и каким образом она применима к Шаблонному методу?
* Что такое невиртуальный интерфейс?
* Почему в С++ рекомендуется делать все виртуальные функции закрытыми?
* Когда следует делать виртуальные функции защищенными?
* Почему Шаблонный метод нельзя использовать для деструкторов?
* Что такое проблема хрупкого базового класса и как избежать ее при использовании Шаблонного метода?

* Что такое паттерн Одиночка?
* Когда можно использовать паттерн Одиночка, а когда его следует избегать?
* Что такое ленивая инициализация и какие проблемы она решает?
* Как сделать инициализацию Одиночки потокобезопасный?
* В чем состоит проблема порядка удаления и какие есть способы ее решения?

* Что такое паттерн Стратегия?
* Как паттерн Стратегия реализуется в С++ на этапе компиляции с помощью обобщенного программирования?
* Какие типы можно использовать в качестве политик?
* Как можно интегрировать политики с главным шаблоном?
* Какие основные недостатки на основе политик?

* Что такое паттерн Адаптер?
* Что такое паттерн Декоратор и чем он отличается от паттерна Адаптер?
* Классическая объектно-ориентированная реализация паттерна Декоратор обычно не рекомендуется в С++. Почему?
* Когда в декораторе класса в С++ следует использовать наследование, а когда композицию?
* Когда в адаптере класса в С++ следует использовать наследование, а когда композицию?
* С++ предлагает общий адаптер функции для каррирования аргументов, ~std::bind~. Каковы его ограничения?
* С++11 предлагает псевдонимы шаблонов, которые можно использовать как адаптеры. Каковы их ограничения?
* Оба паттерна, Адаптер и Политика, можно использовать для расширения или модификации открытого интерфейса класса. Приведите несколько причин, по которым один паттерн следует предпочесть другому

* Что такое паттерн Посетитель?
* Какую проблему решает паттерн Посетитель?
* Что такое двойная диспетчеризация?
* Каковы преимущества паттерна Ациклический посетитель?
* Как паттерн Посетитель помогает реализовать сериализацию?

* Реентерабельность
** Компьютерная программа в целом или её отдельная процедура называется *реентера́бельной* (от англ. reentrant — повторно входимый), если она разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами. При этом второй пользователь может вызвать реентерабельный код до того, как с ним завершит работу первый пользователь и это как минимум не должно привести к ошибке, а при корректной реализации не должно вызвать потери вычислений (то есть не должно появиться необходимости выполнять уже выполненные фрагменты кода).
** *Реентерабельность* тесно связана с безопасностью функции в многопоточной среде (thread-safety), тем не менее, это разные понятия. Обеспечение реентерабельности является ключевым моментом при программировании многозадачных систем, в частности, операционных систем.
*** Для обеспечения реентерабельности необходимо выполнение нескольких условий:
**** никакая часть вызываемого кода не должна модифицироваться;
**** вызываемая процедура не должна сохранять информацию между вызовами;
**** если процедура изменяет какие-либо данные, то они должны быть уникальными для каждого пользователя;
**** процедура не должна возвращать указатели на объекты, общие для разных пользователей.
*** В общем случае, для обеспечения реентерабельности необходимо, чтобы вызывающий процесс или функция каждый раз передавал вызываемому процессу все необходимые данные. Таким образом, функция, которая зависит только от своих параметров, не использует глобальные и статические переменные и вызывает только реентерабельные функции, будет реентерабельной. Если функция использует глобальные или статические переменные, необходимо обеспечить, чтобы каждый пользователь хранил свою локальную копию этих переменных.
